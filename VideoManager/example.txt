// RTSP stuff
// TODO: Remove from global scope, move to a separate file
GMainLoop* rtsp_loop = nullptr;
guint rtsp_server_sid;
size_t rtsp_data_size;
bool is_ready_rtsp = false;

struct RTSPContext {
    GstClockTime timestamp = 0;
};

template <typename T, int MaxLen, typename Container = std::deque<T>>
class queue_data : std::queue<T, Container> {
public:
    void push(const T& value) {
        if (this->size() == MaxLen) {
            std::lock_guard<std::mutex> lock(m_mutex);
            this->c.pop_front();
        }
        std::queue<T, Container>::push(value);
    }

    void clean() {
        while (this->size() > 0) {
            std::lock_guard<std::mutex> lock(m_mutex);
            this->c.pop_front();
        }
    }

    T receive() {
        T out_data;
        std::lock_guard<std::mutex> lock(m_mutex);
        if (!this->c.empty())
            out_data = this->c.front();
        return out_data;
    }
private:
    mutable std::mutex m_mutex;
};


queue_data<cv::Mat, 3> rtsp_manager;


void rtsp_need_data(GstElement* appsrc, guint unused, RTSPContext *ctx) {
    GstBuffer* buffer = gst_buffer_new_allocate(NULL, rtsp_data_size, NULL);
    gst_buffer_fill(buffer, 0, rtsp_manager.receive().data, rtsp_data_size);

    // TODO: Improve FPS/timestamp/duration settings
    GST_BUFFER_PTS(buffer) = ctx->timestamp;
    GST_BUFFER_DURATION(buffer) = gst_util_uint64_scale_int(1, GST_SECOND, 30);
    ctx->timestamp += GST_BUFFER_DURATION(buffer);

    GstFlowReturn ret; // Not used, but prevent annoying warnings
    g_signal_emit_by_name(appsrc, "push-buffer", buffer, &ret);
    gst_buffer_unref(buffer);
}

void rtsp_media_configure(GstRTSPMediaFactory* factory, GstRTSPMedia* media, gpointer user_data) {
    GstElement *element = gst_rtsp_media_get_element(media);
    GstElement *appsrc = gst_bin_get_by_name_recurse_up(GST_BIN(element), "rtsp_src");

    g_object_set_data_full(G_OBJECT(media), "my-extra-data", nullptr, (GDestroyNotify)g_free);
    g_signal_connect(appsrc, "need-data", (GCallback)rtsp_need_data, g_new0(RTSPContext, 1));

    gst_object_unref(appsrc);
    gst_object_unref(element);
}

void start_rtsp_server(cv::Size frame_size) {
    std::string address = config.director.rtsp_address_out;
    uint64 address_last_slash_pos = address.find_last_of("/");
    uint64 address_last_colon_pos = address.find_last_of(":");

    gst_init(nullptr, nullptr);
    rtsp_loop = g_main_loop_new(nullptr, FALSE);

    GstRTSPServer* rtsp_server = gst_rtsp_server_new();
    gst_rtsp_server_set_service(rtsp_server, address.substr(address_last_colon_pos + 1, address_last_slash_pos - address_last_colon_pos - 1).c_str());

    // TODO: Improve factory/pipeline
    GstRTSPMediaFactory* factory = gst_rtsp_media_factory_new();
    std::string launch = config.app.is_using_nvenc
    ? "( appsrc name=rtsp_src format=GST_FORMAT_TIME max-latency=0 caps=video/x-raw,format=BGR,width=" + s(config.director.rtsp_out_width) + ",height=" + s(config.director.rtsp_out_height)
        + ",framerate=" + s(config.director.rtsp_out_fps) + "/1 ! videoconvert ! video/x-raw,format=(string)RGBA ! nvvidconv ! nvv4l2h265enc insert-sps-pps=1 idrinterval=15 insert-aud=1 insert-vui=1 ! video/x-h265,stream-format=byte-stream ! rtph265pay name=pay0 pt=96 )"
    : "( appsrc name=rtsp_src format=GST_FORMAT_TIME max-latency=0 caps=video/x-raw,format=BGR,width=" + s(config.director.rtsp_out_width) + ",height=" + s(config.director.rtsp_out_height)
        + ",framerate=" + s(config.director.rtsp_out_fps) + "/1 ! videoconvert ! videorate ! video/x-raw,format=I420 ! x264enc speed-preset=ultrafast tune=zerolatency ! rtph264pay name=pay0 )";
    gst_rtsp_media_factory_set_launch(factory, launch.c_str());

    // gst_rtsp_media_factory_set_protocols(factory,
    //  GST_RTSP_LOWER_TRANS_UDP_MCAST);

    g_signal_connect(factory, "media-configure", (GCallback)rtsp_media_configure, nullptr);

    GstRTSPMountPoints* mounts = gst_rtsp_server_get_mount_points(rtsp_server);
    gst_rtsp_mount_points_add_factory(mounts, address.substr(address_last_slash_pos).c_str(), factory);
    g_object_unref(mounts);

    rtsp_server_sid = gst_rtsp_server_attach(rtsp_server, nullptr);
    std::cout << "RTSP stream ready at " + address + "\n";

    g_main_loop_run(rtsp_loop);
}

void stop_rtsp_server() {
    g_source_remove(rtsp_server_sid);
    g_main_loop_quit(rtsp_loop);
}



// ---------------------------------------------------------------------------------------------

    std::thread t_rtsp;
    t_rtsp = std::thread([&]() {
        std::thread t_rtsp_server;
        cv::Mat blank_vizgard_img = cv::imread((std::filesystem::exists("cc/background.jpg") ? "cc/background.jpg" : "./Config/Misc/blacklogo.jpg"));
        if (output_frame_size != frame_size) cv::resize(blank_vizgard_img, blank_vizgard_img, output_frame_size, cv::INTER_CUBIC);
        while (!is_ready_rtsp) {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
        if (output_rtsp) {
            t_rtsp_server = std::thread([&]() {
                start_rtsp_server(output_frame_size);
            });
        }
        while (!program_exit_flag) {
            if (video_exit_flag && output_rtsp) {
                rtsp_manager.push(blank_vizgard_img);
            }
            if (remote_update_server_video_out) {
                remote_update_server_video_out = false;
                if (!output_rtsp)
                    continue;
                stop_rtsp_server();
                if (t_rtsp_server.joinable()) t_rtsp_server.join();
                if (config.director.rtsp_address_out.length() > 0) {
                    t_rtsp_server = std::thread([&]() { start_rtsp_server(output_frame_size); });
                }
            }
            if (remote_toggle_rtsp_out) {
                remote_toggle_rtsp_out = false;
                output_rtsp ^= 1;
                if (output_rtsp) {
                    if (config.director.rtsp_address_out.length() > 0) {
                        t_rtsp_server = std::thread([&]() { start_rtsp_server(output_frame_size); });
                    }
                }
                else {
                    rtsp_manager.clean();
                    rtsp_manager.push(blank_vizgard_img);
                    std::this_thread::sleep_for(std::chrono::milliseconds(500));
                    stop_rtsp_server();
                    if (t_rtsp_server.joinable()) t_rtsp_server.join();
                }
                send_remote_status();
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(30));
        }
        stop_rtsp_server();
        if (t_rtsp_server.joinable()) t_rtsp_server.join();
        std::cout << "RTSP stream exits.\n";
    });

